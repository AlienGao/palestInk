(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{471:function(e,s,a){"use strict";a.r(s);var t=a(12),n=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h3",{attrs:{id:"_1-在哪个生命周期内调用异步请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-在哪个生命周期内调用异步请求"}},[e._v("#")]),e._v(" 1. 在哪个生命周期内调用异步请求？")]),e._v(" "),a("p",[e._v("可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：")]),e._v(" "),a("ul",[a("li",[e._v("能更快获取到服务端数据，减少页面 loading 时间；")]),e._v(" "),a("li",[e._v("ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；")])]),e._v(" "),a("h3",{attrs:{id:"_2-父组件可以监听到子组件的生命周期吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-父组件可以监听到子组件的生命周期吗"}},[e._v("#")]),e._v(" 2. 父组件可以监听到子组件的生命周期吗？")]),e._v(" "),a("p",[e._v("比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// Parent.vue\n<Child @mounted="doSomething"/>\n    \n// Child.vue\nmounted() {\n  this.$emit("mounted");\n}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("p",[e._v("以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//  Parent.vue\n<Child @hook:mounted=\"doSomething\" ></Child>\n\ndoSomething() {\n   console.log('父组件监听到 mounted 钩子函数 ...');\n},\n    \n//  Child.vue\nmounted(){\n   console.log('子组件触发 mounted 钩子函数 ...');\n},    \n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br")])]),a("p",[e._v("// 以上输出顺序为：\n// 子组件触发 mounted 钩子函数 ...\n// 父组件监听到 mounted 钩子函数 ..."),a("br"),e._v("\n当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。")]),e._v(" "),a("h3",{attrs:{id:"_3-谈谈你对-keep-alive-的了解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-谈谈你对-keep-alive-的了解"}},[e._v("#")]),e._v(" 3. 谈谈你对 keep-alive 的了解？")]),e._v(" "),a("p",[e._v("keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：")]),e._v(" "),a("ul",[a("li",[e._v("一般结合路由和动态组件一起使用，用于缓存组件；")]),e._v(" "),a("li",[e._v("提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中\nexclude 的优先级比 include 高；")]),e._v(" "),a("li",[e._v("对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。")])]),e._v(" "),a("h3",{attrs:{id:"_4-组件中-data-为什么是一个函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-组件中-data-为什么是一个函数"}},[e._v("#")]),e._v(" 4. 组件中 data 为什么是一个函数？")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// data\ndata() {\n  return {\n\tmessage: \"子组件\",\n\tchildName:this.name\n  }\n}\n\n// new Vue\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: {App}\n})\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br")])]),a("p",[e._v("因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。")]),e._v(" "),a("h3",{attrs:{id:"_5-v-model-的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-v-model-的原理"}},[e._v("#")]),e._v(" 5. v-model 的原理？")]),e._v(" "),a("p",[e._v("我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：")]),e._v(" "),a("ul",[a("li",[e._v("text 和 textarea 元素使用 value 属性和 input 事件；")]),e._v(" "),a("li",[e._v("checkbox 和 radio 使用 checked 属性和 change 事件；")]),e._v(" "),a("li",[e._v("select 字段将 value 作为 prop 并将 change 作为事件。")])]),e._v(" "),a("h3",{attrs:{id:"_6-能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗"}},[e._v("#")]),e._v(" 6. 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？")]),e._v(" "),a("p",[e._v("（1）hash 模式的实现原理")]),e._v(" "),a("p",[e._v("早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("https://www.word.com#search\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("hash  路由模式的实现主要是基于下面几个特性：")]),e._v(" "),a("ul",[a("li",[e._v("URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；")]),e._v(" "),a("li",[e._v("hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；")]),e._v(" "),a("li",[e._v("可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；")]),e._v(" "),a("li",[e._v("我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。")])]),e._v(" "),a("p",[e._v("（2）history 模式的实现原理")]),e._v(" "),a("p",[e._v("HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("window.history.pushState(null, null, path);\nwindow.history.replaceState(null, null, path);\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("history 路由模式的实现主要基于存在下面几个特性：")]),e._v(" "),a("ul",[a("li",[e._v("pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；")]),e._v(" "),a("li",[e._v("我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；")]),e._v(" "),a("li",[e._v("history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。")])]),e._v(" "),a("h3",{attrs:{id:"_7-vue-是如何实现数据双向绑定的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue-是如何实现数据双向绑定的"}},[e._v("#")]),e._v(" 7. Vue 是如何实现数据双向绑定的？")]),e._v(" "),a("p",[e._v("Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示："),a("br"),e._v(" "),a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/19/16ca75871f2e5f80~tplv-t2oaga2asx-watermark.awebp",alt:""}})]),e._v(" "),a("ul",[a("li",[e._v("输入框内容变化时，Data 中的数据同步变化。即 View => Data 的变化。")]),e._v(" "),a("li",[e._v("Data 中的数据变化时，文本节点的内容同步变化。即 Data => View 的变化。")])]),e._v(" "),a("p",[e._v("其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。")]),e._v(" "),a("p",[e._v("Vue 主要通过以下 4 个步骤来实现数据双向绑定的：")]),e._v(" "),a("ul",[a("li",[e._v("实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。")]),e._v(" "),a("li",[e._v("实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。")]),e._v(" "),a("li",[e._v("实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。")]),e._v(" "),a("li",[e._v("实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。")])]),e._v(" "),a("h3",{attrs:{id:"_8-vue-框架怎么实现对象和数组的监听"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue-框架怎么实现对象和数组的监听"}},[e._v("#")]),e._v(" 8. Vue 框架怎么实现对象和数组的监听？")]),e._v(" "),a("p",[e._v("Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])  // observe 功能为监测数据的变化\n    }\n  }\n\n  /**\n   * 对属性进行递归遍历\n   */\n  let childOb = !shallow && observe(val) // observe 功能为监测数据的变化\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br")])]),a("p",[e._v("通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。")]),e._v(" "),a("h3",{attrs:{id:"_9-proxy-与-object-defineproperty-优劣对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-proxy-与-object-defineproperty-优劣对比"}},[e._v("#")]),e._v(" 9. Proxy 与 Object.defineProperty 优劣对比")]),e._v(" "),a("h4",{attrs:{id:"proxy-的优势如下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proxy-的优势如下"}},[e._v("#")]),e._v(" Proxy 的优势如下:")]),e._v(" "),a("ul",[a("li",[e._v("Proxy 可以直接监听对象而非属性；")]),e._v(" "),a("li",[e._v("Proxy 可以直接监听数组的变化；")]),e._v(" "),a("li",[e._v("Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；")]),e._v(" "),a("li",[e._v("Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；")]),e._v(" "),a("li",[e._v("Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；")])]),e._v(" "),a("h4",{attrs:{id:"object-defineproperty-的优势如下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty-的优势如下"}},[e._v("#")]),e._v(" Object.defineProperty 的优势如下:")]),e._v(" "),a("p",[e._v("兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。")]),e._v(" "),a("h3",{attrs:{id:"_10-vue-怎么用-vm-set-解决对象新增属性不能响应的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-vue-怎么用-vm-set-解决对象新增属性不能响应的问题"}},[e._v("#")]),e._v(" 10. Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？")]),e._v(" "),a("p",[e._v("受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)  来实现为对象添加响应式属性，那框架本身是如何实现的呢？"),a("br"),e._v("\n我们查看对应的 Vue 源码："),a("em",[e._v("vue/src/core/instance/index.js")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export function set (target: Array<any> | Object, key: any, val: any): any {\n  // target 为数组  \n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    // 修改数组的长度, 避免索引>数组长度导致splcie()执行有误\n    target.length = Math.max(target.length, key)\n    // 利用数组的splice变异方法触发响应式  \n    target.splice(key, 1, val)\n    return val\n  }\n  // key 已经存在，直接修改属性值  \n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val\n    return val\n  }\n  const ob = (target: any).__ob__\n  // target 本身就不是响应式数据, 直接赋值\n  if (!ob) {\n    target[key] = val\n    return val\n  }\n  // 对属性进行响应式处理\n  defineReactive(ob.value, key, val)\n  ob.dep.notify()\n  return val\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br"),a("span",{staticClass:"line-number"},[e._v("24")]),a("br"),a("span",{staticClass:"line-number"},[e._v("25")]),a("br")])]),a("p",[e._v("我们阅读以上源码可知，vm.$set 的实现原理是：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("如果目标是数组，直接使用数组的 splice 方法触发相应式；")])]),e._v(" "),a("li",[a("p",[e._v("如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用"),a("em",[e._v("defineReactive")]),e._v("方法进行响应式处理"),a("em",[e._v("defineReactive")]),e._v("方法就是Vue在初始化对象时，给对象属性采用 Object.defineProperty动态添加getter和setter的功能所调用的方法。")])])]),e._v(" "),a("h3",{attrs:{id:"_11-什么是-mvvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-什么是-mvvm"}},[e._v("#")]),e._v(" 11. 什么是 MVVM？")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/19/16ca75871ec53fba~tplv-t2oaga2asx-watermark.awebp",alt:""}}),a("br"),e._v("\n（1）View 层"),a("br"),e._v("\nView 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。")]),e._v(" "),a("p",[e._v("（2）Model 层"),a("br"),e._v("\nModel 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。")]),e._v(" "),a("p",[e._v("（3）ViewModel 层"),a("br"),e._v("\nViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。")]),e._v(" "),a("p",[e._v("MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。")]),e._v(" "),a("p",[e._v("（1）View 层")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<div id="app">\n    <p>{{message}}</p>\n    <button v-on:click="showMessage()">Click me</button>\n</div>\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("（2）ViewModel 层")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var app = new Vue({\n    el: '#app',\n    data: {  // 用于描述视图状态   \n        message: 'Hello Vue!', \n    },\n    methods: {  // 用于描述视图行为  \n        showMessage(){\n            let vm = this;\n            alert(vm.message);\n        }\n    },\n    created(){\n        let vm = this;\n        // Ajax 获取 Model 层的数据\n        ajax({\n            url: '/your/server/data/api',\n            success(res){\n                vm.message = res;\n            }\n        });\n    }\n})\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br")])]),a("p",[e._v("（3） Model 层")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('{\n    "url": "/your/server/data/api",\n    "res": {\n        "success": true,\n        "name": "IoveC",\n        "domain": "www.cnblogs.com"\n    }\n}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])])])}),[],!1,null,null,null);s.default=n.exports}}]);